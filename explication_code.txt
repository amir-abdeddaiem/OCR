================================================================================
           EXPLICATION COMPL√àTE ET D√âTAILL√âE DU FICHIER main.py
              (Programme OCR - Extraction de texte depuis images/PDF)
================================================================================

Auteur de l'explication : GitHub Copilot
Date : 26 f√©vrier 2026

Ce document explique CHAQUE ligne du code main.py pour un d√©butant complet
en Python et en informatique. Prends ton temps pour lire, c'est normal
si tout n'est pas clair du premier coup !

================================================================================
TABLE DES MATI√àRES
================================================================================
1. C'est quoi ce programme ?
2. Vocabulaire de base
3. Explication ligne par ligne
   3.1  Les imports (lignes 1-12)
   3.2  Fonction _is_pdf (lignes 15-16)
   3.3  Fonction _load_images_from_pdf (lignes 19-57)
   3.4  Fonction _load_images (lignes 60-72)
   3.5  Fonction _preprocess_for_ocr (lignes 75-101)
   3.6  Fonction _paddle_is_usable (lignes 104-111)
   3.7  Fonction _create_paddle_ocr (lignes 114-121)
   3.8  Fonction _windows_ocr_available (lignes 124-134)
   3.9  Fonction _windows_ocr_image_text (lignes 137-193)
   3.10 Fonction _extract_text_from_paddle_result (lignes 196-243)
   3.11 Fonction main (lignes 246-308)
   3.12 Le point d'entr√©e (lignes 311-312)
4. Comment utiliser le programme
5. R√©sum√© du flux complet

================================================================================
1. C'EST QUOI CE PROGRAMME ?
================================================================================

Ce programme fait de l'OCR. OCR signifie "Optical Character Recognition"
(Reconnaissance Optique de Caract√®res). En gros, il prend une IMAGE ou un
fichier PDF, il "regarde" le texte qui est dessin√© dessus (comme un humain
lirait une photo d'un document), et il le convertit en TEXTE que l'ordinateur
peut comprendre et manipuler.

Exemple concret :
  - Tu as un CV en PDF scann√© (c'est une image, pas du texte s√©lectionnable)
  - Tu lances ce programme
  - Il te sort le texte du CV dans un fichier .txt

Le programme supporte DEUX moteurs d'OCR :
  1. PaddleOCR : un moteur OCR puissant bas√© sur l'intelligence artificielle
     (n√©cessite Python 3.10 ou 3.11)
  2. Windows OCR : le moteur OCR int√©gr√© √† Windows 10/11
     (fonctionne avec n'importe quel Python sur Windows)

================================================================================
2. VOCABULAIRE DE BASE
================================================================================

Avant de plonger dans le code, voici les mots importants :

- VARIABLE : Un "nom" qui stocke une valeur. Ex: age = 25
  "age" est la variable, 25 est la valeur.

- FONCTION : Un bloc de code r√©utilisable qui fait une t√¢che pr√©cise.
  On la "d√©finit" avec "def" et on l'"appelle" avec son nom suivi de ().
  Ex: def dire_bonjour():  ‚Üí d√©finition
      dire_bonjour()       ‚Üí appel

- PARAM√àTRE : Une valeur qu'on passe √† une fonction.
  Ex: def saluer(nom):  ‚Üí "nom" est un param√®tre
      saluer("Alice")   ‚Üí "Alice" est la valeur pass√©e

- TYPE : Le "genre" d'une donn√©e. Ex: str = texte, int = nombre entier,
  bool = vrai/faux, list = liste d'√©l√©ments.

- IMPORT : Charger une biblioth√®que (un ensemble de code √©crit par d'autres)
  pour l'utiliser dans notre programme.

- BIBLIOTH√àQUE (ou module/package) : Du code d√©j√† √©crit par d'autres
  d√©veloppeurs qu'on peut r√©utiliser. Ex: cv2 pour traiter les images.

- TABLEAU NUMPY (np.ndarray) : Une fa√ßon efficace de stocker des images
  en m√©moire. Une image couleur est un tableau 3D :
  hauteur √ó largeur √ó 3 canaux (Bleu, Vert, Rouge).

- BGR vs RGB : Deux fa√ßons d'ordonner les couleurs.
  RGB = Rouge-Vert-Bleu (standard courant)
  BGR = Bleu-Vert-Rouge (utilis√© par OpenCV)

- try/except : Un m√©canisme pour "essayer" du code et "attraper" les erreurs
  sans que le programme plante brutalement.

- async/await : Un m√©canisme pour ex√©cuter du code qui prend du temps
  (comme lire un fichier) sans bloquer tout le programme. C'est de la
  "programmation asynchrone".

================================================================================
3. EXPLICATION LIGNE PAR LIGNE
================================================================================

--------------------------------------------------------------------------------
3.1 LES IMPORTS (lignes 1 √† 12)
--------------------------------------------------------------------------------

```python
import argparse
```
‚Üí "argparse" est une biblioth√®que INT√âGR√âE √† Python (pas besoin de l'installer).
  Elle sert √† lire les ARGUMENTS qu'on tape dans le terminal.
  Exemple : quand tu tapes "python main.py -i cv.pdf -l fr", argparse comprend
  que -i veut dire "input" et que sa valeur est "cv.pdf".

```python
import os
```
‚Üí "os" est une biblioth√®que int√©gr√©e qui permet d'interagir avec le SYST√àME
  D'EXPLOITATION (Operating System). Ici on l'utilise pour :
  - V√©rifier si un fichier existe (os.path.exists)
  - Extraire l'extension d'un fichier (os.path.splitext)

```python
import sys
```
‚Üí "sys" est une biblioth√®que int√©gr√©e qui donne acc√®s au SYST√àME Python.
  Ici on l'utilise pour :
  - Savoir sur quel OS on tourne (sys.platform ‚Üí "win32" pour Windows)

```python
from typing import List, Optional
```
‚Üí "typing" sert √† indiquer les TYPES des variables dans le code.
  C'est comme des √©tiquettes : √ßa ne change pas le fonctionnement, mais √ßa
  aide les d√©veloppeurs √† comprendre le code.
  - List[str] ‚Üí "une liste de textes"
  - Optional[int] ‚Üí "un entier OU rien (None)"

```python
import cv2
```
‚Üí "cv2" est la biblioth√®que OpenCV (Open Computer Vision). C'est LA r√©f√©rence
  pour manipuler des images en Python. On l'utilise ici pour :
  - Lire des images depuis des fichiers
  - Convertir les couleurs (RGB ‚Üî BGR ‚Üî Gris)
  - Redimensionner, flouter, binariser des images
  - Encoder des images en PNG

```python
import numpy as np
```
‚Üí "numpy" est LA biblioth√®que pour les calculs math√©matiques en Python.
  "as np" veut dire "on lui donne le surnom np" pour √©crire moins.
  Ici on l'utilise car les images sont stock√©es comme des tableaux numpy.

```python
try:
    from paddleocr import PaddleOCR
except Exception:
    PaddleOCR = None
```
‚Üí Ce bloc "try/except" essaie d'importer PaddleOCR.
  - SI √ßa marche : PaddleOCR est disponible, on peut l'utiliser.
  - SI √ßa √©choue (module pas install√©) : on met PaddleOCR = None
    (None = "rien", √ßa veut dire "pas disponible").
  Le programme ne plante PAS, il note juste que PaddleOCR n'est pas l√†.

--------------------------------------------------------------------------------
3.2 FONCTION _is_pdf (lignes 15-16)
--------------------------------------------------------------------------------

```python
def _is_pdf(path: str) -> bool:
    return os.path.splitext(path)[1].lower() == ".pdf"
```

EXPLICATION :
- "def" ‚Üí on d√©finit une nouvelle fonction
- "_is_pdf" ‚Üí le nom de la fonction. Le "_" au d√©but est une CONVENTION
  qui signifie "cette fonction est priv√©e / interne" (pas faite pour √™tre
  appel√©e de l'ext√©rieur).
- "(path: str)" ‚Üí elle prend un param√®tre "path" (chemin du fichier),
  qui est de type str (texte).
- "-> bool" ‚Üí elle retourne un bool√©en (True ou False).

CE QUE FAIT LA FONCTION :
- os.path.splitext("cv.pdf") retourne ("cv", ".pdf")
  ‚Üí √ßa s√©pare le nom de l'extension
- [1] prend le 2e √©l√©ment ‚Üí ".pdf"
- .lower() met en minuscules ‚Üí ".pdf" (utile si le fichier s'appelle "CV.PDF")
- == ".pdf" compare : est-ce que c'est un PDF ?
- Retourne True (oui) ou False (non)

EXEMPLE :
  _is_pdf("mon_cv.pdf")  ‚Üí True
  _is_pdf("photo.jpg")   ‚Üí False
  _is_pdf("DOC.PDF")     ‚Üí True (gr√¢ce √† .lower())

--------------------------------------------------------------------------------
3.3 FONCTION _load_images_from_pdf (lignes 19-57)
--------------------------------------------------------------------------------

```python
def _load_images_from_pdf(pdf_path: str, max_pages: Optional[int]) -> List[np.ndarray]:
```
‚Üí Cette fonction charge un PDF et convertit ses pages en IMAGES.
  - pdf_path : chemin vers le fichier PDF
  - max_pages : nombre maximum de pages √† lire (ou None = toutes)
  - Retourne une LISTE d'images (chaque image est un tableau numpy)

```python
    try:
        import fitz  # PyMuPDF
    except Exception as exc:
        raise SystemExit(...)
```
‚Üí On essaie d'importer "fitz", qui est le nom de code de la biblioth√®que
  PyMuPDF (elle sert √† lire les PDF).
  Si PyMuPDF n'est pas install√©, le programme s'arr√™te avec un message
  d'erreur clair qui dit comment l'installer.
  "raise SystemExit(...)" = arr√™ter le programme et afficher un message.

```python
    doc = fitz.open(pdf_path)
```
‚Üí Ouvre le fichier PDF. "doc" est maintenant un objet qui repr√©sente
  le document PDF en m√©moire.

```python
    images: List[np.ndarray] = []
```
‚Üí Cr√©e une liste VIDE qui va stocker les images des pages.
  "List[np.ndarray]" est juste un indice de type pour dire "liste d'images".

```python
    page_count = len(doc)
    if page_count == 0:
        return images
```
‚Üí len(doc) = nombre de pages dans le PDF.
  Si le PDF est vide (0 pages), on retourne la liste vide tout de suite.

```python
    pages_to_read = page_count
    if max_pages is not None:
        pages_to_read = min(pages_to_read, max_pages)
```
‚Üí On d√©termine combien de pages lire.
  - Par d√©faut : toutes les pages
  - Si l'utilisateur a demand√© un maximum (ex: --max-pages 1),
    on prend le plus petit entre le total et le maximum demand√©.
  min(5, 1) = 1 ‚Üí on ne lira qu'une page m√™me s'il y en a 5.

```python
    mat = fitz.Matrix(2, 2)
```
‚Üí Cr√©e une MATRICE de zoom 2√ó2. Cela double la r√©solution de l'image.
  Pourquoi ? Parce que l'OCR fonctionne mieux avec des images en haute
  r√©solution (200-300 DPI au lieu de 72 DPI par d√©faut).
  DPI = "Dots Per Inch" = points par pouce = mesure de r√©solution.

```python
    for i in range(pages_to_read):
```
‚Üí Boucle "for" : on r√©p√®te le bloc pour chaque page.
  range(3) ‚Üí donne 0, 1, 2 ‚Üí on traite les pages 0, 1, 2.

```python
        page = doc.load_page(i)
```
‚Üí Charge la page num√©ro "i" du PDF.

```python
        pix = page.get_pixmap(matrix=mat, alpha=False)
```
‚Üí Convertit la page en image (pixmap = carte de pixels).
  - matrix=mat ‚Üí applique le zoom 2√ó
  - alpha=False ‚Üí pas de transparence (on n'en a pas besoin)

```python
        img = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.height, pix.width, pix.n)
```
‚Üí Convertit les donn√©es brutes de l'image en tableau numpy.
  - pix.samples ‚Üí les octets bruts des pixels
  - dtype=np.uint8 ‚Üí chaque valeur est un entier de 0 √† 255
    (0 = noir, 255 = blanc pour un canal)
  - .reshape(...) ‚Üí donne la forme 3D : hauteur √ó largeur √ó canaux

```python
        if pix.n == 1:
            img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
        elif pix.n == 3:
            img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
        else:
            img = img[:, :, :3]
            img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
```
‚Üí pix.n = nombre de canaux de couleur :
  - 1 canal = image en niveaux de gris ‚Üí on la convertit en BGR (3 canaux)
  - 3 canaux = RGB (Rouge Vert Bleu) ‚Üí on convertit en BGR pour OpenCV
  - autre (ex: 4 = RGBA avec transparence) ‚Üí on garde les 3 premiers canaux
    puis on convertit en BGR
  
  Pourquoi BGR ? OpenCV utilise l'ordre Bleu-Vert-Rouge par convention.

```python
        images.append(img)
    return images
```
‚Üí Ajoute l'image de la page dans notre liste, puis passe √† la page suivante.
  √Ä la fin de la boucle, on retourne toutes les images.

--------------------------------------------------------------------------------
3.4 FONCTION _load_images (lignes 60-72)
--------------------------------------------------------------------------------

```python
def _load_images(input_path: str, max_pages: Optional[int]) -> List[np.ndarray]:
```
‚Üí Fonction "chef d'orchestre" pour charger les images, qu'il s'agisse
  d'un PDF ou d'une image simple (PNG, JPG...).

```python
    if not os.path.exists(input_path):
        raise SystemExit(f"Erreur: fichier introuvable: {input_path}")
```
‚Üí V√©rifie que le fichier existe. Si non ‚Üí arr√™t avec message d'erreur.
  f"..." est une "f-string" : on peut mettre des variables entre {}
  qui seront remplac√©es par leur valeur.

```python
    if _is_pdf(input_path):
        images = _load_images_from_pdf(input_path, max_pages=max_pages)
        if not images:
            raise SystemExit("Erreur: PDF vide ou pages non lisibles.")
        return images
```
‚Üí Si c'est un PDF ‚Üí appelle la fonction sp√©cialis√©e PDF.
  Si elle retourne une liste vide ‚Üí erreur.

```python
    image = cv2.imread(input_path)
    if image is None:
        raise SystemExit("Erreur: image non lisible (format non support√© ou fichier corrompu).")
    return [image]
```
‚Üí Sinon c'est une image classique ‚Üí cv2.imread() la lit.
  Si √ßa √©choue (retourne None) ‚Üí erreur.
  On retourne une liste avec UNE seule image (pour garder le m√™me format
  que pour les PDF qui peuvent avoir plusieurs pages).

--------------------------------------------------------------------------------
3.5 FONCTION _preprocess_for_ocr (lignes 75-101)
--------------------------------------------------------------------------------

C'est la fonction de PR√â-TRAITEMENT d'image. Elle "nettoie" l'image pour
que l'OCR la lise mieux. C'est comme nettoyer ses lunettes avant de lire !

```python
def _preprocess_for_ocr(image_bgr: np.ndarray) -> np.ndarray:
```
‚Üí Prend une image BGR, retourne une image nettoy√©e.

```python
    gray = cv2.cvtColor(image_bgr, cv2.COLOR_BGR2GRAY)
```
‚Üí √âTAPE 1 : Convertir en niveaux de gris.
  Une image couleur a 3 canaux (B, G, R). En gris, il n'y a qu'un seul
  canal (0=noir ‚Üí 255=blanc). C'est plus simple √† analyser pour l'OCR.

```python
    h, w = gray.shape[:2]
    if max(h, w) < 900:
        scale = 2
        gray = cv2.resize(gray, (w * scale, h * scale), interpolation=cv2.INTER_CUBIC)
```
‚Üí √âTAPE 2 : Si l'image est PETITE (moins de 900 pixels de c√¥t√©),
  on la DOUBLE de taille. L'OCR a besoin que les lettres soient assez
  grandes pour les reconna√Ætre.
  - h = hauteur, w = largeur
  - cv2.resize = redimensionner
  - INTER_CUBIC = m√©thode d'interpolation de bonne qualit√© (lisse les pixels)

```python
    blur = cv2.GaussianBlur(gray, (5, 5), 0)
```
‚Üí √âTAPE 3 : FLOU GAUSSIEN l√©g√®rement. √áa peut sembler contre-intuitif,
  mais un l√©ger flou √©limine le "bruit" (petits points parasites) de l'image.
  (5, 5) = taille du noyau de flou (5√ó5 pixels).

```python
    _, th = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
```
‚Üí √âTAPE 4 : BINARISATION. Transforme l'image en NOIR ET BLANC pur
  (pas de gris). Chaque pixel devient soit 0 (noir) soit 255 (blanc).
  - La m√©thode d'OTSU trouve automatiquement le meilleur seuil.
  - Le "_" devant la virgule = on ignore la premi√®re valeur retourn√©e
    (le seuil trouv√©, on n'en a pas besoin).

```python
    if np.mean(th) < 127:
        th = cv2.bitwise_not(th)
```
‚Üí √âTAPE 5 : Si l'image a un FOND SOMBRE (la moyenne des pixels < 127),
  on INVERSE noir‚Üîblanc. L'OCR attend du texte noir sur fond blanc.
  np.mean = calcule la moyenne de tous les pixels.
  bitwise_not = inverse chaque bit (0‚Üí255, 255‚Üí0).

```python
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 2))
    th = cv2.morphologyEx(th, cv2.MORPH_OPEN, kernel, iterations=1)
```
‚Üí √âTAPE 6 : NETTOYAGE MORPHOLOGIQUE. √âlimine les tout petits points
  parasites restants.
  - kernel = un petit rectangle 2√ó2 pixels
  - MORPH_OPEN = "ouverture" = √©rode puis dilate. √áa supprime les petits
    points blancs isol√©s sans affecter le texte.

```python
    return cv2.cvtColor(th, cv2.COLOR_GRAY2BGR)
```
‚Üí √âTAPE 7 : Reconvertit en 3 canaux (BGR) car PaddleOCR pr√©f√®re
  les images en couleur, m√™me si c'est du noir et blanc.

R√âSUM√â DU PR√â-TRAITEMENT :
  Image couleur ‚Üí Gris ‚Üí Agrandir si petit ‚Üí Flou ‚Üí Noir/Blanc ‚Üí 
  Inverser si besoin ‚Üí Nettoyer ‚Üí Image BGR nettoy√©e

--------------------------------------------------------------------------------
3.6 FONCTION _paddle_is_usable (lignes 104-111)
--------------------------------------------------------------------------------

```python
def _paddle_is_usable() -> bool:
    if PaddleOCR is None:
        return False
    try:
        import paddle
    except Exception:
        return False
    return True
```
‚Üí V√©rifie si PaddleOCR est utilisable :
  1. PaddleOCR doit √™tre import√© (pas None)
  2. Le module "paddle" (le moteur d'IA) doit aussi √™tre install√©
  Si les deux conditions sont remplies ‚Üí True, sinon ‚Üí False.

--------------------------------------------------------------------------------
3.7 FONCTION _create_paddle_ocr (lignes 114-121)
--------------------------------------------------------------------------------

```python
def _create_paddle_ocr(lang: str):
    if PaddleOCR is None:
        raise RuntimeError("PaddleOCR non install√©")
    try:
        return PaddleOCR(use_textline_orientation=True, lang=lang)
    except TypeError:
        return PaddleOCR(use_angle_cls=True, lang=lang)
```
‚Üí Cr√©e un objet PaddleOCR configur√© pour la langue demand√©e.
  - use_textline_orientation=True ‚Üí d√©tecte l'orientation du texte
    (utile si le texte est pench√© ou tourn√©)
  - lang=lang ‚Üí la langue (ex: "fr" pour fran√ßais)
  
  Le try/except g√®re la COMPATIBILIT√â entre anciennes et nouvelles versions :
  - Nouvelles versions : use_textline_orientation
  - Anciennes versions : use_angle_cls (m√™me fonction, ancien nom)

--------------------------------------------------------------------------------
3.8 FONCTION _windows_ocr_available (lignes 124-134)
--------------------------------------------------------------------------------

```python
def _windows_ocr_available() -> bool:
    if sys.platform != "win32":
        return False
    try:
        import winrt.windows.media.ocr
        import winrt.windows.graphics.imaging
        import winrt.windows.storage.streams
        import winrt.windows.globalization
    except Exception:
        return False
    return True
```
‚Üí V√©rifie si l'OCR Windows est disponible :
  1. On doit √™tre sur Windows (sys.platform == "win32")
  2. Les 4 modules WinRT n√©cessaires doivent √™tre install√©s
  
  WinRT = Windows Runtime, c'est l'interface pour utiliser les
  fonctionnalit√©s de Windows depuis Python.

--------------------------------------------------------------------------------
3.9 FONCTION _windows_ocr_image_text (lignes 137-193)
--------------------------------------------------------------------------------

C'est la fonction la plus COMPLEXE. Elle utilise le moteur OCR int√©gr√©
√† Windows pour extraire le texte d'une image.

```python
def _windows_ocr_image_text(image_bgr: np.ndarray, lang: str) -> str:
```
‚Üí Prend une image et une langue, retourne le texte reconnu.

```python
    if not _windows_ocr_available():
        raise RuntimeError(...)
```
‚Üí V√©rification de s√©curit√© : l'OCR Windows est-il disponible ?

```python
    import asyncio
    from winrt.windows.globalization import Language
    from winrt.windows.graphics.imaging import BitmapDecoder
    from winrt.windows.media.ocr import OcrEngine
    from winrt.windows.storage.streams import DataWriter, InMemoryRandomAccessStream
```
‚Üí Importe les modules n√©cessaires :
  - asyncio : pour la programmation asynchrone (voir vocabulaire)
  - Language : pour sp√©cifier la langue de l'OCR
  - BitmapDecoder : pour d√©coder une image en bitmap
  - OcrEngine : le moteur OCR de Windows lui-m√™me
  - DataWriter, InMemoryRandomAccessStream : pour √©crire des donn√©es en m√©moire

```python
    ok, buf = cv2.imencode(".png", image_bgr)
    if not ok:
        return ""
    png_bytes = buf.tobytes()
```
‚Üí Convertit l'image numpy en fichier PNG en m√©moire.
  - cv2.imencode(".png", image) ‚Üí encode l'image au format PNG
  - ok = True si √ßa a march√©
  - buf = les donn√©es PNG brutes
  - .tobytes() ‚Üí convertit en bytes (octets), format que Windows comprend

```python
    async def _run() -> str:
```
‚Üí D√©finit une fonction ASYNCHRONE (async). Pourquoi ? Parce que les API
  Windows WinRT sont asynchrones : elles utilisent "await" pour attendre
  les r√©sultats sans bloquer.

```python
        stream = InMemoryRandomAccessStream()
        writer = DataWriter(stream)
        writer.write_bytes(png_bytes)
        await writer.store_async()
        await writer.flush_async()
        writer.detach_stream()
```
‚Üí √âcrit l'image PNG dans un "flux en m√©moire" (stream).
  C'est comme cr√©er un fichier temporaire, mais en m√©moire (plus rapide).
  - InMemoryRandomAccessStream() ‚Üí cr√©e le flux vide
  - DataWriter(stream) ‚Üí cr√©e un "√©crivain" pour ce flux
  - write_bytes ‚Üí √©crit les bytes PNG
  - store_async ‚Üí stocke (sauvegarde dans le flux)
  - flush_async ‚Üí vide le tampon (s'assure que tout est √©crit)
  - detach_stream ‚Üí d√©tache l'√©crivain du flux
  Le mot "await" avant chaque op√©ration = "attends que √ßa finisse"

```python
        stream.seek(0)
        decoder = await BitmapDecoder.create_async(stream)
        software_bitmap = await decoder.get_software_bitmap_async()
```
‚Üí - seek(0) ‚Üí remet le curseur au d√©but du flux (comme rembobiner un film)
  - BitmapDecoder.create_async ‚Üí d√©code le PNG en image bitmap Windows
  - get_software_bitmap_async ‚Üí obtient le bitmap en m√©moire

```python
        engine = None
        try:
            engine = OcrEngine.try_create_from_language(Language(lang))
        except Exception:
            engine = None

        if engine is None:
            engine = OcrEngine.try_create_from_user_profile_languages()
        if engine is None:
            raise RuntimeError("Impossible d'initialiser l'OCR Windows...")
```
‚Üí Cr√©e le moteur OCR :
  1. D'abord, essaie de cr√©er un moteur pour la langue demand√©e (ex: "fr")
  2. Si √ßa √©choue, essaie avec les langues du profil Windows de l'utilisateur
  3. Si √ßa √©choue encore ‚Üí erreur

```python
        result = await engine.recognize_async(software_bitmap)
        return (result.text or "").strip()
```
‚Üí Lance la reconnaissance OCR sur l'image bitmap.
  - result.text ‚Üí le texte reconnu
  - "or """ ‚Üí si result.text est None, utilise "" (texte vide)
  - .strip() ‚Üí enl√®ve les espaces/retours √† la ligne au d√©but et √† la fin

```python
    try:
        return asyncio.run(_run())
    except RuntimeError:
        loop = asyncio.new_event_loop()
        try:
            return loop.run_until_complete(_run())
        finally:
            loop.close()
```
‚Üí Ex√©cute la fonction asynchrone :
  - asyncio.run() ‚Üí m√©thode standard pour lancer du code async
  - Si √ßa √©choue (RuntimeError, ex: une boucle async existe d√©j√†),
    on cr√©e manuellement une nouvelle boucle √©v√©nementielle.
  - finally ‚Üí s'ex√©cute TOUJOURS, m√™me en cas d'erreur (pour fermer la boucle)

--------------------------------------------------------------------------------
3.10 FONCTION _extract_text_from_paddle_result (lignes 196-243)
--------------------------------------------------------------------------------

Cette fonction prend le r√©sultat BRUT de PaddleOCR et en extrait le texte.

PaddleOCR retourne ses r√©sultats dans un format complexe :
  [ [ [coordonn√©es_du_rectangle, ("texte reconnu", score_de_confiance)], ... ] ]

Chaque mot reconnu est associ√© √† :
  - Un rectangle (les 4 coins de la zone o√π le mot a √©t√© trouv√©)
  - Le texte reconnu
  - Un score de confiance (0 √† 1, ex: 0.95 = 95% s√ªr)

```python
    if result is None:
        return ""
```
‚Üí Si aucun r√©sultat ‚Üí retourne du texte vide.

```python
    def is_word(item) -> bool:
```
‚Üí Fonction INTERNE (d√©finie √† l'int√©rieur d'une autre).
  V√©rifie si un √©l√©ment du r√©sultat est un "mot" valide :
  - Doit √™tre une liste/tuple avec au moins 2 √©l√©ments
  - Le 2e √©l√©ment doit √™tre une liste/tuple dont le 1er √©l√©ment est du texte

```python
    def is_page(item) -> bool:
```
‚Üí V√©rifie si un √©l√©ment est une "page" (une liste de mots).

```python
    pages: List[list]
    if isinstance(result, list) and len(result) > 0 and is_page(result[0]):
        pages = result
    elif isinstance(result, list) and (len(result) == 0 or is_word(result[0])):
        pages = [result]
    else:
        pages = []
```
‚Üí D√©termine la STRUCTURE du r√©sultat :
  - Si result[0] est une page ‚Üí c'est une liste de pages
  - Si result[0] est un mot ‚Üí c'est une seule page (on l'emballe dans une liste)
  - Sinon ‚Üí liste vide

  "isinstance(x, list)" v√©rifie si x est une liste.

```python
    lines: List[str] = []
    for page in pages:
        for word in page:
            if not is_word(word):
                continue
            text = word[1][0]
            if text.strip():
                lines.append(text.strip())
    return "\n".join(lines)
```
‚Üí Parcourt toutes les pages, puis tous les mots de chaque page.
  - word[1][0] ‚Üí le texte du mot
  - .strip() ‚Üí enl√®ve les espaces
  - si le texte n'est pas vide ‚Üí on l'ajoute √† la liste
  - "\n".join(lines) ‚Üí assemble tous les mots avec des retours √† la ligne
  
  "continue" = sauter au tour de boucle suivant (ignorer ce mot).

--------------------------------------------------------------------------------
3.11 FONCTION main (lignes 246-308)
--------------------------------------------------------------------------------

C'est la FONCTION PRINCIPALE du programme. Elle orchestre tout.

```python
def main(argv: Optional[List[str]] = None) -> int:
```
‚Üí Fonction principale. Retourne un entier (0 = succ√®s, autre = erreur).
  argv = arguments de ligne de commande (ou None = utiliser sys.argv).

--- Bloc argparse (lignes 247-278) ---

```python
    parser = argparse.ArgumentParser(description="OCR (image ou PDF) -> texte")
```
‚Üí Cr√©e un "parseur" d'arguments qui comprend les options du terminal.

```python
    parser.add_argument("--input", "-i", required=True, ...)
    parser.add_argument("--lang", "-l", default="fr", ...)
    parser.add_argument("--output", "-o", default=None, ...)
    parser.add_argument("--max-pages", type=int, default=None, ...)
    parser.add_argument("--debug-images", action="store_true", ...)
```
‚Üí D√©finit les OPTIONS du programme :

  --input (-i)  : OBLIGATOIRE. Le fichier √† traiter.
                   Ex: -i cv.pdf

  --lang (-l)   : OPTIONNEL. Langue de l'OCR (d√©faut: "fr").
                   Ex: -l en (pour l'anglais)

  --output (-o) : OPTIONNEL. Fichier .txt o√π sauvegarder le r√©sultat.
                   Ex: -o resultat.txt

  --max-pages   : OPTIONNEL. Limite le nombre de pages d'un PDF.
                   Ex: --max-pages 3 (ne traite que les 3 premi√®res pages)

  --debug-images: OPTIONNEL. Si pr√©sent, sauvegarde les images nettoy√©es
                   dans des fichiers cleaned_1.png, cleaned_2.png, etc.
                   Utile pour comprendre pourquoi l'OCR donne de mauvais r√©sultats.
                   "action=store_true" ‚Üí c'est un drapeau (flag) : pr√©sent = True, absent = False.

```python
    args = parser.parse_args(argv)
```
‚Üí Analyse (parse) les arguments. Apr√®s cette ligne, on peut utiliser :
  args.input, args.lang, args.output, args.max_pages, args.debug_images

--- Chargement des images (ligne 280) ---

```python
    images = _load_images(args.input, max_pages=args.max_pages)
```
‚Üí Charge les images depuis le fichier d'entr√©e.

--- Choix du moteur OCR (lignes 282-291) ---

```python
    backend: str
    ocr = None
    if _paddle_is_usable():
        try:
            ocr = _create_paddle_ocr(args.lang)
            backend = "paddle"
        except Exception:
            ocr = None
            backend = "windows"
    else:
        backend = "windows"
```
‚Üí Choisit quel moteur OCR utiliser :
  1. Si PaddleOCR est disponible ‚Üí on l'utilise (backend = "paddle")
  2. Sinon ‚Üí on bascule sur Windows OCR (backend = "windows")
  "backend" = le "moteur" utilis√© en arri√®re-plan.

```python
    if backend == "windows" and not _windows_ocr_available():
        raise SystemExit(...)
```
‚Üí Si on n'a NI PaddleOCR NI Windows OCR ‚Üí on ne peut rien faire ‚Üí erreur.

--- Boucle d'extraction (lignes 298-306) ---

```python
    extracted_pages: List[str] = []
    for idx, img in enumerate(images, start=1):
```
‚Üí Parcourt chaque image avec son num√©ro (idx = 1, 2, 3...).
  "enumerate" ajoute un compteur √† la boucle.

```python
        cleaned = _preprocess_for_ocr(img)
```
‚Üí Nettoie l'image pour l'OCR.

```python
        if args.debug_images:
            cv2.imwrite(f"cleaned_{idx}.png", cleaned)
```
‚Üí Si --debug-images est activ√©, sauvegarde l'image nettoy√©e.

```python
        if backend == "paddle":
            result = ocr.ocr(cleaned, cls=True)
            extracted_pages.append(_extract_text_from_paddle_result(result))
        else:
            extracted_pages.append(_windows_ocr_image_text(cleaned, args.lang))
```
‚Üí Selon le moteur choisi :
  - PaddleOCR ‚Üí appelle ocr.ocr() puis extrait le texte
  - Windows ‚Üí appelle _windows_ocr_image_text()
  Ajoute le texte extrait dans la liste.

--- Affichage et sauvegarde (lignes 308-316) ---

```python
    text = "\n\n".join([t for t in extracted_pages if t.strip()]).strip()
```
‚Üí Assemble le texte de toutes les pages :
  - [t for t in extracted_pages if t.strip()] ‚Üí garde seulement les pages
    non vides (c'est une "list comprehension", un raccourci Python)
  - "\n\n".join(...) ‚Üí les s√©pare par 2 retours √† la ligne
  - .strip() ‚Üí enl√®ve les espaces au d√©but/fin

```python
    print("\n===== TEXTE EXTRAIT =====\n")
    print(text)
```
‚Üí Affiche le texte dans le terminal.

```python
    if args.output:
        with open(args.output, "w", encoding="utf-8") as f:
            f.write(text)
            f.write("\n")
        print(f"\nTexte sauvegard√© dans: {args.output}")
```
‚Üí Si un fichier de sortie a √©t√© demand√© :
  - open(..., "w", encoding="utf-8") ‚Üí ouvre le fichier en √©criture, encodage UTF-8
    (UTF-8 g√®re les accents fran√ßais comme √©, √®, √™, etc.)
  - "with" ‚Üí ouvre le fichier et le FERME automatiquement √† la fin du bloc
  - f.write(text) ‚Üí √©crit le texte
  - Affiche un message de confirmation

```python
    return 0
```
‚Üí Retourne 0 = tout s'est bien pass√© (convention informatique :
  0 = succ√®s, autre nombre = erreur).

--------------------------------------------------------------------------------
3.12 LE POINT D'ENTR√âE (lignes 311-312)
--------------------------------------------------------------------------------

```python
if __name__ == "__main__":
    raise SystemExit(main())
```
‚Üí C'est le POINT DE D√âPART du programme.

  "__name__" est une variable sp√©ciale de Python :
  - Quand tu ex√©cutes "python main.py", __name__ vaut "__main__"
  - Quand un autre fichier fait "import main", __name__ vaut "main"

  Donc ce bloc ne s'ex√©cute QUE quand on lance directement le fichier.
  
  "raise SystemExit(main())" :
  1. Appelle main() ‚Üí ex√©cute tout le programme
  2. main() retourne 0 (ou un code d'erreur)
  3. SystemExit(0) ‚Üí dit √† Python de quitter avec le code 0

================================================================================
4. COMMENT UTILISER LE PROGRAMME
================================================================================

Ouvre un terminal (PowerShell) dans le dossier du projet, puis :

--- Cas de base : OCR d'un PDF en fran√ßais ---
  python main.py -i cv.pdf -l fr -o resultat.txt

--- OCR d'une image en anglais ---
  python main.py -i photo.png -l en -o output.txt

--- PDF, seulement les 2 premi√®res pages ---
  python main.py -i document.pdf -l fr -o texte.txt --max-pages 2

--- Mode debug (sauvegarder les images pr√©-trait√©es) ---
  python main.py -i cv.pdf -l fr -o texte.txt --debug-images
  ‚Üí Cr√©e cleaned_1.png, cleaned_2.png, etc. pour voir ce que l'OCR "voit"

--- Juste afficher le texte (sans sauvegarder) ---
  python main.py -i cv.pdf -l fr

LANGUES SUPPORT√âES (exemples) :
  fr = fran√ßais
  en = anglais
  ar = arabe
  es = espagnol
  de = allemand

================================================================================
5. R√âSUM√â DU FLUX COMPLET
================================================================================

Voici ce qui se passe quand tu tapes :
  python main.py -i cv.pdf -l fr -o out.txt --max-pages 1

√âTAPE 1 : ANALYSE DES ARGUMENTS
  ‚Üí argparse lit "-i cv.pdf -l fr -o out.txt --max-pages 1"
  ‚Üí input="cv.pdf", lang="fr", output="out.txt", max_pages=1

√âTAPE 2 : CHARGEMENT
  ‚Üí Le fichier cv.pdf est ouvert par PyMuPDF
  ‚Üí La page 1 est convertie en image (tableau numpy BGR)
  ‚Üí R√©sultat : une liste avec 1 image

√âTAPE 3 : CHOIX DU MOTEUR
  ‚Üí PaddleOCR disponible ? Non (Python 3.14, pas compatible)
  ‚Üí Windows OCR disponible ? Oui (les modules WinRT sont install√©s)
  ‚Üí Moteur choisi : "windows"

√âTAPE 4 : PR√â-TRAITEMENT
  ‚Üí L'image passe par le pipeline :
    Couleur ‚Üí Gris ‚Üí (Agrandir si petit) ‚Üí Flou ‚Üí Noir/Blanc ‚Üí
    (Inverser si fond sombre) ‚Üí Nettoyage ‚Üí BGR

√âTAPE 5 : OCR
  ‚Üí L'image nettoy√©e est envoy√©e au moteur OCR Windows
  ‚Üí Windows analyse l'image et reconna√Æt les caract√®res
  ‚Üí R√©sultat : du texte brut

√âTAPE 6 : R√âSULTAT
  ‚Üí Le texte est affich√© dans le terminal
  ‚Üí Le texte est sauvegard√© dans out.txt

================================================================================
FIN DE L'EXPLICATION
================================================================================

Si tu as des questions, n'h√©site pas √† exp√©rimenter :
  - Active --debug-images pour voir les images nettoy√©es
  - Change la langue avec -l
  - Essaie avec diff√©rents fichiers PDF ou images

Bonne continuation dans ton apprentissage de Python ! üêç
